\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

\title{Yankovinator: Song Parody Generator\\
\large Technical Documentation}
\author{Shyamal Suhana Chandra}
\date{Copyright \textcopyright{} 2025}

\lstset{
    language=Swift,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false
}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

Yankovinator is a Swift-based application that converts songs into parodies using Apple's NaturalLanguage framework and Ollama for intelligent text generation. The system maintains the original song's syllable structure while generating new lyrics that follow theme-based keyword constraints.

\section{Architecture}

\subsection{Core Components}

Yankovinator consists of four main components:

\begin{enumerate}
    \item \textbf{SyllableCounter}: Analyzes syllable structure using NaturalLanguage framework
    \item \textbf{OllamaClient}: Interfaces with Ollama API for parody generation
    \item \textbf{ParodyGenerator}: Orchestrates the parody creation process
    \item \textbf{Yankovinator}: Main library interface
\end{enumerate}

\subsection{Technology Stack}

\begin{itemize}
    \item \textbf{Swift 6.2+}: Primary programming language
    \item \textbf{NaturalLanguage}: Apple framework for linguistic analysis
    \item \textbf{Ollama}: Local LLM for text generation
    \item \textbf{AsyncHTTPClient}: Asynchronous HTTP client for API communication
    \item \textbf{ArgumentParser}: CLI argument parsing
\end{itemize}

\section{Usage}

\subsection{Command Line Interface}

The CLI tool provides a simple interface for generating parodies:

\begin{lstlisting}
yankovinator <lyrics-file> [--keywords <keywords-file>] 
            [--ollama-url <url>] [--model <model-name>]
            [--output <output-file>] [--analyze] [--verbose]
\end{lstlisting}

\subsection{Programmatic Usage}

\begin{lstlisting}
import Yankovinator

let lyrics = [
    "Twinkle twinkle little star",
    "How I wonder what you are"
]

let keywords = [
    "space": "the physical universe beyond Earth",
    "stars": "luminous celestial bodies"
]

let parody = try await Yankovinator.generateParody(
    originalLyrics: lyrics,
    keywords: keywords
)
\end{lstlisting}

\section{API Reference}

\subsection{SyllableCounter}

\subsubsection{countSyllables(in:)}
Counts syllables in a single word.

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{word: String} - The word to analyze
\end{itemize}

\textbf{Returns:} \texttt{Int} - Number of syllables

\subsubsection{countSyllablesInLine(\_:)}
Counts total syllables in a line of text.

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{line: String} - The line of text
\end{itemize}

\textbf{Returns:} \texttt{Int} - Total syllable count

\subsubsection{analyzeSongStructure(\_:)}
Analyzes syllable structure of a complete song.

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{lyrics: [String]} - Array of lyric lines
\end{itemize}

\textbf{Returns:} \texttt{[Int]} - Array of syllable counts per line

\subsection{ParodyGenerator}

\subsubsection{generateParody(originalLyrics:keywords:progressCallback:refinementPasses:verbose:)}
Generates a parody matching the original song's structure with semantic coherence.

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{originalLyrics: [String]} - Original song lines
    \item \texttt{keywords: [String: String]} - Theme keywords and definitions
    \item \texttt{progressCallback: ((Int, Int) -> Void)?} - Optional progress callback
    \item \texttt{refinementPasses: Int} - Number of refinement passes (default: 2)
    \item \texttt{verbose: Bool} - Whether to print verbose messages
\end{itemize}

\textbf{Returns:} \texttt{[String]} - Generated parody lines with semantic coherence

\textbf{Refinement Process:}
\begin{enumerate}
    \item Word-by-word syllable matching refinement
    \item Semantic coherence refinement (ensures lines work together thematically)
    \item Capitalization and punctuation matching to match original style exactly
\end{enumerate}

\subsection{Yankovinator}

\subsubsection{generateParody(originalLyrics:keywords:ollamaURL:ollamaModel:)}
Main entry point for parody generation.

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{originalLyrics: [String]} - Original song lines
    \item \texttt{keywords: [String: String]} - Theme keywords and definitions
    \item \texttt{ollamaURL: String} - Ollama API base URL (default: http://localhost:11434)
    \item \texttt{ollamaModel: String} - Ollama model name (default: llama3.2)
\end{itemize}

\textbf{Returns:} \texttt{[String]} - Generated parody lines

\section{Algorithm}

\subsection{Syllable Counting}

The syllable counting algorithm uses a combination of:

\begin{enumerate}
    \item NaturalLanguage tokenization for word separation
    \item Vowel counting heuristics
    \item Special case handling for silent 'e' and 'le' endings
    \item Word-by-word syllable analysis for precise matching
\end{enumerate}

\subsection{Rhyme Detection}

Yankovinator automatically detects rhyming schemes from original lyrics:

\begin{itemize}
    \item Extracts last words from each line using NaturalLanguage tokenization
    \item Compares phonetic patterns using vowel sequences and consonant patterns
    \item Groups lines by rhyming patterns (A, B, C, etc.)
    \item Enforces rhyming constraints during generation
    \item Supports common rhyme schemes: ABAB, AABB, AAAA, etc.
\end{itemize}

\subsection{Parody Generation}

The parody generation process:

\begin{enumerate}
    \item Analyze original song's syllable structure
    \item Detect rhyming scheme from original lyrics
    \item For each line:
        \begin{enumerate}
            \item Extract syllable count requirement (total and word-by-word)
            \item Determine rhyming constraints based on detected scheme
            \item Build prompt with theme keywords and semantic context
            \item Request generation from Ollama with previous lines for coherence
            \item Validate and clean response
            \item Refine word-by-word syllable matching
            \item Refine semantic coherence with previous lines
            \item Apply capitalization and punctuation to match original style exactly
        \end{enumerate}
    \item Return complete parody
\end{enumerate}

\subsection{Semantic Coherence}

Yankovinator employs advanced semantic coherence techniques to ensure generated lyrics work together meaningfully:

\begin{itemize}
    \item \textbf{Context Awareness}: Each line generation considers up to 8 previous lines for narrative continuity
    \item \textbf{Theme Advancement}: Lines are generated to actively advance the chosen theme, not just mention keywords
    \item \textbf{Semantic Refinement}: A dedicated refinement pass ensures each line semantically connects with previous lines
    \item \textbf{Narrative Flow}: The system maintains logical progression and consistent imagery throughout the parody
    \item \textbf{Theme Integration}: Keywords are woven naturally into the semantic content of each line
\end{itemize}

The semantic coherence system uses Ollama's language understanding to:
\begin{itemize}
    \item Build upon established narrative, theme, and emotional arcs
    \item Use consistent imagery, metaphors, and thematic elements
    \item Ensure each line contributes meaningfully to the overall story
    \item Maintain logical flow and progression from previous lines
\end{itemize}

\subsection{Text Processing and Grammar}

Yankovinator includes sophisticated text processing to ensure grammatically correct output:

\begin{itemize}
    \item \textbf{Contraction Preservation}: Apostrophes in contractions (e.g., "don't", "can't", "it's", "won't") are preserved during text cleaning, ensuring natural and grammatically correct poetry
    \item \textbf{Quote Handling}: Only wrapping quotes are removed from generated text, while internal punctuation and apostrophes are maintained
    \item \textbf{Syllable Counting with Contractions}: The syllable counter properly handles contractions by tokenizing them as single words, then removing punctuation for accurate syllable counting
    \item \textbf{Prompt Engineering}: Generation prompts explicitly encourage the use of proper contractions when appropriate for natural speech patterns
\end{itemize}

\subsection{Capitalization and Punctuation Matching}

Yankovinator ensures that generated parodies match the exact capitalization and punctuation style of the original song:

\begin{itemize}
    \item \textbf{Capitalization Pattern Extraction}: The system analyzes which words in the original line are capitalized and which are lowercase
    \item \textbf{Punctuation Preservation}: All punctuation marks (commas, periods, apostrophes, quotes, etc.) are extracted and preserved in their exact positions
    \item \textbf{Pattern Application}: After generation and refinement, the capitalization and punctuation patterns from the original line are automatically applied to the generated line
    \item \textbf{Word-by-Word Matching}: Each word in the generated line receives the same capitalization treatment as the corresponding word in the original line
    \item \textbf{Spacing Preservation}: The exact spacing and punctuation placement between words is maintained
\end{itemize}

The capitalization and punctuation matching process:
\begin{enumerate}
    \item Extract capitalization pattern from original line (which words are uppercase/lowercase)
    \item Extract punctuation pattern (all punctuation marks and their positions)
    \item Generate parody line with semantic coherence and syllable matching
    \item Apply capitalization pattern word-by-word to generated line
    \item Apply punctuation pattern to match original exactly
    \item Validate final output matches original style
\end{enumerate}

\section{Documentation}

Yankovinator includes comprehensive documentation:

\begin{itemize}
    \item \textbf{Technical Paper} (this document): Architecture, algorithms, and implementation details
    \item \textbf{Presentation}: Slide deck with overview, features, and usage examples
    \item \textbf{Reference Manual}: Complete API documentation with function signatures, parameters, return types, and usage examples
\end{itemize}

All documentation is available on GitHub Pages and can be generated locally using LaTeX.

\section{Testing}

The project includes comprehensive tests using XCTest:

\begin{itemize}
    \item Unit tests for syllable counting
    \item Integration tests for parody generation
    \item Keyword extraction tests
\end{itemize}

Run tests with:
\begin{lstlisting}[language=bash]
swift test
\end{lstlisting}

\section{Installation}

\subsection{Requirements}

\begin{itemize}
    \item Swift 6.3 or later
    \item macOS 13+ or iOS 16+
    \item Ollama installed and running
    \item Model: llama3.2:3b (install with \texttt{ollama pull llama3.2:3b})
\end{itemize}

\subsection{Homebrew Installation (Recommended)}

The easiest way to install Yankovinator-swift is using Homebrew:

\begin{lstlisting}[language=bash]
# Add the tap
brew tap shyamalschandra/yankovinator-swift

# Install Yankovinator-swift
brew install yankovinator-swift

# Verify installation
yankovinator --help
keyword-generator --help
\end{lstlisting}

The Homebrew formula automatically handles all dependencies and builds the package in release mode.

\subsection{Build from Source}

For development or if you prefer building from source:

\begin{lstlisting}[language=bash]
# Clone repository
git clone https://github.com/shyamalschandra/Yankovinator-swift.git
cd Yankovinator-swift

# Build
swift build

# Run CLI
swift run yankovinator --help
\end{lstlisting}

\section{Configuration}

\subsection{Ollama Setup}

Ensure Ollama is running and accessible:

\begin{lstlisting}[language=bash]
# Start Ollama
ollama serve

# Pull required model
ollama pull llama3.2
\end{lstlisting}

\section{Examples}

\subsection{Example Input}

\textbf{lyrics.txt:}
\begin{lstlisting}
Twinkle twinkle little star
How I wonder what you are
Up above the world so high
Like a diamond in the sky
\end{lstlisting}

\textbf{keywords.txt:}
\begin{lstlisting}
science: the study of natural phenomena
space: the physical universe beyond Earth
exploration: the action of traveling to discover
\end{lstlisting}

\subsection{Example Output}

The generated parody maintains syllable structure while incorporating the theme keywords.

\section{Troubleshooting}

\subsection{Common Issues}

\begin{itemize}
    \item \textbf{Ollama not found}: Ensure Ollama is running at the specified URL
    \item \textbf{Model not available}: Pull the required model using \texttt{ollama pull}
    \item \textbf{Syllable count mismatch}: The algorithm uses heuristics and may not be 100\% accurate
\end{itemize}

\section{License}

Copyright \textcopyright{} 2025, Shyamal Suhana Chandra

\section{References}

\begin{itemize}
    \item Apple NaturalLanguage Framework: \url{https://developer.apple.com/documentation/NaturalLanguage}
    \item Ollama Documentation: \url{https://ollama.ai/docs}
    \item Swift Package Manager: \url{https://swift.org/package-manager/}
\end{itemize}

\end{document}

